use foobar 
db.persons.insert({name:"liuxun"})
show collections
db.persons.find()
db.persons.findOne()
db.persons.update({name:"liuxun",{$set:{name:"xun"}})
	
1.创建一个数据库
use [datebaseName]
2.查看所有数据库
show dbs
3.给指定数据库添加集合并添加记录
db.[documentName].insert({...})
4.查看数据库中的所有文档
show collections
5.更新文档数据
db.[documentName].update({查询条件},{更新条件})
6.删除文档中的数据	
db.persons.remove({name:"liuxun"})

命令行下
var p = db.persons.findOne();
db.persons.update({p,{name:"liuxun"}})	
	
设置过期索引
db.index.ensureIndex({time:-1},{expireAfterSeconds:30})	
db.index.insert({time:new Date()})
	
全文索引
db.article.ensureIndex({"article":"text"})	
db.article.insert({"article":"aa bb cc dd ee"})
db.article.insert({"article":"aa bb cc hh ee"})	
db.article.find({$text:{$search:"aa"}})	
	
连接mongodb
mongodb://root:proAL0357@dds-bp116b4651f8aa641.mongodb.rds.aliyuncs.com:3717,dds-bp116b4651f8aa642.mongodb.rds.aliyuncs.com:3717/admin?replicaSet=mgset-4960747	

for(var i=1;i<3;i++) db.customers.insert({id:i,name:"xun",age:10+i,password:100+i})

$lt $gte $in $ne $nin $or $and $exists

db.customers.find({age:{$lt:15}})
db.customers.find({age:{$gte:15}})
db.customers.find({age:{$gte:12,$lt:15}})
db.customers.find({age:{$in:[15,18]}})
db.customers.find({age:{$nin:[15,18]}})
db.customers.find({age:{$ne:12}})
db.customers.find({$or:[{age:14},{age:16}]})
db.customers.find({$and:[{age:15},{name:"xun"}]})
db.customers.find({password:{$exists:true}})
db.customers.find({age:15,name:"xun"})

-------------------------------------------
 db.customers.find({name:"xun"},{_id:0,age:1})
后面的{} 为字段选择器

db.customers.find({}).sort({age:-1})  按照age 字段降序
db.customers.find({}).skip(10).limit(5).sort({age:-1})


db.customers.find({likes:"xixi"})   其中likes 字段为数组 查询likes 字段包含xixi
 db.customers.find({"likes.1":"xixi"}) 必须数组第二个元素为xixi

for(var i = 1; i < 10;i++) db.customers.insert({name:"Jordan"+i,country:"American"})
for(var i = 1; i < 10;i++) db.customers.insert({name:"gaga"+i,country:"American"})
for(var i = 1; i < 10;i++) db.customers.insert({name:"nham"+i,country:"UK"})
for(var i = 1; i < 10;i++) db.customers.insert({name:"brown"+i,country:"UK"})
for(var i = 1; i < 10;i++) db.customers.insert({name:"huahua"+i,country:"CK"})

db.customers.ensureIndex({name:1,country:-1})

db.customers.getIndexes() 查看索引
db.customers.dropIndex("name_1") 删除索引

db.setProfilingLevel(1,100) 监控慢查询


Objectld 类型的值由 12 个字节组成 ， 前面 4 个字节表示的是一个时间截 ， 精确到秒 ， 紧接着的 3 个字节
表示的是机器唯一标示 ， 接着 2 个字节表示的进程 id , 最后 3 个字节是一个随机的计数器
5a92715d6550f6576300ce84

----------------------更新操作  update
db.user.update({name:"liuxun"},{$set:{name:"liuxun2"}})
db.user.update({name:"liuxun"},{$set:{name:"liuxun2"}},{upsert:true})
db.user.update({name:"liuxun"},{$set:{name:"liuxun2"},$inc:{score:10}})

db.user.update({name:"liuxun2"},{name:"haha"}) 更新并覆盖字段

db.user.update({name:"haha"},{$set:{name:"liuxun2"}},{multi:true})

multi 是否更新所有字段 默认false
upsert 如果不存在就插入

----------------------删除操作
db.user.remove({name:"liuxun"})  删除匹配的所有元素
db.user.remove({name:"liuxun"},1) 删除匹配的第一个元素
db.user.remove() 删除所有文档 但是不删除索引


----------------------aggregate 聚集操作-----------------
db.customers.update({},{$set:{score:10}},{multi:1})   给所有document 新增字段

db.customers.aggregate([{$match:{country:"UK"}},{$sort:{name:-1}}])
查找匹配country为"UK",并根据name 倒叙排列

db.customers.aggregate([{$match:{country:"UK"}},{$group:{_id:"$name",total:{$sum:"$score"}}}])
匹配country为"UK",并根据字段name 分组 统计score 字段，(_id, total 为别名)

$ match : 过滤文档,只传递匹配的文档到管道中的下一个步骤
$limit : 限制管道中文档的数量
$skip : 跳过指定数量的文档 ， 返回剩下的文档 。
$sort : 对所有输入的文档进行排序 。
$group: 对所有文档进行分组然后计算聚集结果 。
$out : 将管道中的文档输出到一个具体的集合中 ， 这个必须是管道操作中的最后一步

与$group操作一起使用的计算聚集值的操作符有以下几个 。
$first : 返回 group 操作后的第一值 。
$first : 返回 group 操作后的最后一个值 。
$max: 返回 group 操作后的最大值 。
$min: 返回 group 操作后的最小值 。
$avg: 返回 group 操作后的平均值 。
$sum: 返回 group 操作后所有值的和

db.customers.aggregate([{$group:{_id:null,count:{$sum:1}}}])
select count(*) from customers

db.customers.aggregate([{$group:{_id:null,total:{$sum:"$score"}}}])
select sum(score) from customers

db.customers.aggregate([{$group:{_id:"$name",total:{$sum:"$score"}}}])
select name,sum(score) from customers group by name

db.customers.aggregate([{$group:{_id:{name:"$name",country:"$country"},total:{$sum:"$score"}}}])

db.customers.aggregate([{$group:{_id:"$name",count:{$sum:1}}},{$match:{count:{$gte:1}}}])
select name,count(*) from customers group by name having count(*)>1


------------------MapReduce---------------------------

db.customers.mapReduce(
  function()
  {
    emit(this.country,this.score);
  },
  function(key,values)
  {
    return Array.sum(values);
  },
  {
    query:{country:"UK"},
    outresult:"cons"
  }
)

db.customers.distinct("country") 根据country 去重
db.collection.find(<query>).count()

db.collection.count()


group 函数与 distinct — 样 ， 返回的结果集不能大于 16 MB ， 不能在分片集群上进行
操作且 group 不能处理超过 10000 个唯一键值 。 如果我们的聚集操作超过了这个限制 ， 只
有使用上面介绍的管道聚集或 MapReduce 方案